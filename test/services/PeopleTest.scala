/**
 * Generated by apidoc - http://www.apidoc.me
 * Service version: 0.1.0-SNAPSHOT
 * apidoc:0.9.48 http://localhost:9000/movio/apidoc-generator-reference/0.1.0-SNAPSHOT/play_app_tests
 */

package services

import com.typesafe.config. { ConfigFactory, Config }
import org.scalatestplus.play.OneServerPerSuite
import play.api.test._
import play.api.Configuration
import play.api.libs.concurrent.Execution.Implicits.defaultContext
import scala.util.{ Try, Success }
import scala.concurrent.duration._
import scala.language.postfixOps

import movio.testtools.MovioSpec
import movio.testtools.kafka.{ KafkaTestKit, KafkaTestKitUtils }

class PeopleSystemTest extends MovioSpec with KafkaTestKit with OneServerPerSuite with FutureAwaits with DefaultAwaitTimeout {
  import movio.apidoc.generator.reference.v0._
  import movio.apidoc.generator.reference.v0.models._
  import movio.apidoc.generator.reference.v0.kafka._

  val kafkaServer = createKafkaServer()
  kafkaServer.startup()

  override def afterAll() = {
    kafkaServer.shutdown()
    zkServer.stop()
  }

  describe("People") {
    
    it("POST Person Single") {
      val consumer = new KafkaPersonConsumer(testConfig, "consumer-group")
      val client = new Client(apiUrl = s"http://localhost:$port")
      val promise = client.people.postV0AndPersonByTenant(tenant, personEntity1)
      val result = await(promise)
      result shouldBe personEntity1

      def processor(messages: Map[String, Seq[KafkaPerson]]): Try[Map[String, Seq[KafkaPerson]]] = Success(messages)
      awaitCondition("Message should be on the queue", interval = 500 millis) {
        val kafkaResult = consumer.processBatchThenCommit(processor, 1).get(tenant)
        kafkaResult.map(_.v0).head shouldBe result
      }
      consumer.shutdown
    }

    it("POST Person Batch") {
      val consumer = new KafkaPersonConsumer(testConfig, "consumer-group")
      val client = new Client(apiUrl = s"http://localhost:$port")
      val promise = client.people.postV0ByTenant(tenant, personEntities)
      val result = await(promise)
      result shouldBe personEntities.size

      def processor(messages: Map[String, Seq[KafkaPerson]]): Try[Map[String, Seq[KafkaPerson]]] = Success(messages)
      awaitCondition("Message should be on the queue", interval = 500 millis) {
        val kafkaResult = consumer.processBatchThenCommit(processor, 100).get(tenant)
        kafkaResult.map(_.v0) shouldBe personEntities
      }
      consumer.shutdown
    }
  }

  val personEntity1 = 
    Person (
      id = "id1",
      name = "name1",
      dob = None,
      addresses = List.empty
    )
val personEntity2 = 
    Person (
      id = "id2",
      name = "name2",
      dob = None,
      addresses = List.empty
    )
  val personEntities = Seq(personEntity1, personEntity2)

  lazy val brokerConnectionString = kafkaServer.config.hostName + ":" + kafkaServer.config.port
  lazy val tenant = "test"

  lazy val testConfig = ConfigFactory.parseString(s"""
      |configuration {
      |  log-on-startup = false
      |}
      |
      |movio.apidoc.generator.reference.kafka {
      |  producer {
      |    broker-connection-string : "$brokerConnectionString"
      |  }
      |}
      |
      |movio.apidoc.generator.reference.kafka {
      |  consumer {
      |    offset-storage-type = "kafka"
      |    offset-storage-dual-commit = false
      |    timeout.ms = "100"
      |    zookeeper.connection = "${zkServer.getConnectString}"
      |  }
      |}
      |""".stripMargin)
    .withFallback(ConfigFactory.load())


  import scala.collection.JavaConversions._
  override lazy val app: FakeApplication = new FakeApplication(
    additionalConfiguration = testConfig.entrySet.map(v => v.getKey -> v.getValue.unwrapped).toMap
  )
}
